{"version":3,"file":"mapbox-gl-interpolate-heatmap.cjs","sources":["../src/layer.ts"],"sourcesContent":["import earcut from 'earcut';\nimport mapboxgl, { CustomLayerInterface } from 'mapbox-gl';\n\ntype MapboxInterpolateHeatmapLayerOptions = {\n  id: string;\n  data: { lat: number; lon: number; val: number }[];\n  framebufferFactor?: number;\n  maxValue?: number;\n  minValue?: number;\n  opacity?: number;\n  p?: number;\n  aoi?: { lat: number; lon: number }[];\n  valueToColor?: string;\n  valueToColor4?: string;\n  textureCoverSameAreaAsROI?: boolean;\n};\n\nclass MapboxInterpolateHeatmapLayer implements CustomLayerInterface {\n  id: string;\n  data: { lat: number; lon: number; val: number }[];\n  framebufferFactor: number;\n  maxValue: number;\n  minValue: number;\n  opacity: number;\n  p: number;\n  aoi?: { lat: number; lon: number }[];\n  valueToColor?: string;\n  valueToColor4?: string;\n  textureCoverSameAreaAsROI: boolean;\n  points: number[][] = [];\n  // Custom Props\n  aPositionComputation?: number;\n  aPositionDraw?: number;\n  canvas?: HTMLCanvasElement;\n  computationFramebuffer: WebGLFramebuffer | null = null;\n  computationProgram: WebGLProgram | null = null;\n  computationTexture: WebGLTexture | null = null;\n  computationVerticesBuffer: WebGLBuffer | null = null;\n  drawingVerticesBuffer: WebGLBuffer | null = null;\n  drawProgram: WebGLProgram | null = null;\n  framebufferHeight?: number;\n  framebufferWidth?: number;\n  indicesBuffer: WebGLBuffer | null = null;\n  indicesNumber: number | null = null;\n  renderingMode: '2d' | '3d' = '2d';\n  resizeFramebuffer?: () => void;\n  type: 'custom' = 'custom' as const;\n  uComputationTexture: WebGLUniformLocation | null = null;\n  uFramebufferSize: WebGLUniformLocation | null = null;\n  uMatrixComputation: WebGLUniformLocation | null = null;\n  uMatrixDraw: WebGLUniformLocation | null = null;\n  uOpacity: WebGLUniformLocation | null = null;\n  uP: WebGLUniformLocation | null = null;\n  uScreenSizeDraw: WebGLUniformLocation | null = null;\n  uUi: WebGLUniformLocation | null = null;\n  uXi: WebGLUniformLocation | null = null;\n\n  constructor(options: MapboxInterpolateHeatmapLayerOptions) {\n    this.id = options.id || '';\n    this.data = options.data || [];\n    this.aoi = options.aoi || [];\n    this.valueToColor =\n      options.valueToColor ||\n      `\n      vec3 valueToColor(float value) {\n          return vec3(max((value-0.5)*2.0, 0.0), 1.0 - 2.0*abs(value - 0.5), max((0.5-value)*2.0, 0.0));\n      }\n  `;\n    this.valueToColor4 =\n      options.valueToColor4 ||\n      `\n      vec4 valueToColor4(float value, float defaultOpacity) {\n          return vec4(valueToColor(value), defaultOpacity);\n      }\n  `;\n    this.opacity = options.opacity ?? 0.5;\n    this.minValue = options.minValue ?? Infinity;\n    this.maxValue = options.maxValue ?? -Infinity;\n    this.p = options.p ?? 3;\n    this.framebufferFactor = options.framebufferFactor ?? 0.3;\n    // Having a framebufferFactor < 1 and a texture that don't cover the entire map results in visual artifacts, so we prevent this situation\n    this.textureCoverSameAreaAsROI = this.framebufferFactor === 1;\n  }\n\n  onAdd(map: mapboxgl.Map, gl: WebGL2RenderingContext): void {\n    if (\n      !gl.getExtension('EXT_color_buffer_float') ||\n      !gl.getExtension('EXT_float_blend')\n    ) {\n      throw 'WebGL extension not supported';\n    }\n    this.canvas = map.getCanvas();\n    const vertexSource = `\n              precision highp float;\n              attribute vec2 a_Position;\n              uniform mat4 u_Matrix;\n              void main() {\n                  gl_Position = u_Matrix * vec4(a_Position, 0.0, 1.0);\n              }\n          `;\n    const fragmentSource = `\n              precision highp float;\n              ${this.valueToColor}\n              ${this.valueToColor4}\n              uniform sampler2D u_ComputationTexture;\n              uniform vec2 u_ScreenSize;\n              uniform float u_Opacity;\n              void main(void) {\n                  vec4 data = texture2D(u_ComputationTexture, vec2(gl_FragCoord.x/u_ScreenSize.x, gl_FragCoord.y/u_ScreenSize.y));\n                  float u = data.x/data.y;\n                  u += u_Opacity*0.00000001; // force WebGL to use u_Opacity. This might not be the case depending on valueToColor4\n                  gl_FragColor = valueToColor4(u, u_Opacity);\n              }\n          `;\n    const computationVertexSource = `\n              precision highp float;\n              uniform mat4 u_Matrix;\n              uniform vec2 xi;\n              varying vec2 xiNormalized;\n              attribute vec2 a_Position;\n              void main() {\n                  vec4 xiProjected = u_Matrix * vec4(xi, 0.0, 1.0);\n                  xiNormalized = vec2(xiProjected.x / xiProjected.w, xiProjected.y / xiProjected.w);\n                  gl_Position = u_Matrix * vec4(a_Position, 0.0, 1.0);\n              }\n          `;\n    const computationFragmentSource = `\n              precision highp float;\n              uniform float ui;\n              varying vec2 xiNormalized;\n              uniform float p;\n              uniform vec2 u_FramebufferSize;\n              void main() {\n                  vec2 x = vec2(gl_FragCoord.x/u_FramebufferSize.x, gl_FragCoord.y/u_FramebufferSize.y);\n                  vec2 xi = vec2((xiNormalized.x + 1.)/2., (xiNormalized.y + 1.)/2.);\n                  float dist = distance(x, xi);\n                  float wi = 1.0/pow(dist, p);\n                  gl_FragColor = vec4(ui*wi, wi, 0.0, 1.0);\n              }\n          `;\n    const computationVertexShader = createVertexShader(\n      gl,\n      computationVertexSource,\n    );\n    if (!computationVertexShader)\n      throw new Error('error: computation vertex shader not created');\n    const computationFragmentShader = createFragmentShader(\n      gl,\n      computationFragmentSource,\n    );\n    if (!computationFragmentShader)\n      throw new Error('error: computation fragment shader not created');\n    this.computationProgram = createProgram(\n      gl,\n      computationVertexShader,\n      computationFragmentShader,\n    );\n    if (!this.computationProgram)\n      throw new Error('error: computation fragment shader not created');\n    this.aPositionComputation = gl.getAttribLocation(\n      this.computationProgram,\n      'a_Position',\n    );\n    this.uMatrixComputation = gl.getUniformLocation(\n      this.computationProgram,\n      'u_Matrix',\n    );\n    this.uUi = gl.getUniformLocation(this.computationProgram, 'ui');\n    this.uXi = gl.getUniformLocation(this.computationProgram, 'xi');\n    this.uP = gl.getUniformLocation(this.computationProgram, 'p');\n    this.uFramebufferSize = gl.getUniformLocation(\n      this.computationProgram,\n      'u_FramebufferSize',\n    );\n    if (\n      this.aPositionComputation < 0 ||\n      !this.uMatrixComputation ||\n      !this.uUi ||\n      !this.uXi ||\n      !this.uP ||\n      !this.uFramebufferSize\n    ) {\n      throw 'WebGL error: Failed to get the storage location of computation variable';\n    }\n    const drawingVertexShader = createVertexShader(gl, vertexSource);\n    if (!drawingVertexShader)\n      throw new Error('error: drawing vertex shader not created');\n    const drawingFragmentShader = createFragmentShader(gl, fragmentSource);\n    if (!drawingFragmentShader)\n      throw new Error('error: drawing fragment shader not created');\n    this.drawProgram = createProgram(\n      gl,\n      drawingVertexShader,\n      drawingFragmentShader,\n    );\n    if (!this.drawProgram)\n      throw new Error('error: drawing program not created');\n    this.aPositionDraw = gl.getAttribLocation(this.drawProgram, 'a_Position');\n    this.uMatrixDraw = gl.getUniformLocation(this.drawProgram, 'u_Matrix');\n    this.uComputationTexture = gl.getUniformLocation(\n      this.drawProgram,\n      'u_ComputationTexture',\n    );\n    this.uScreenSizeDraw = gl.getUniformLocation(\n      this.drawProgram,\n      'u_ScreenSize',\n    );\n    this.uOpacity = gl.getUniformLocation(this.drawProgram, 'u_Opacity');\n    if (\n      this.aPositionDraw < 0 ||\n      !this.uMatrixDraw ||\n      !this.uComputationTexture ||\n      !this.uScreenSizeDraw ||\n      !this.uOpacity\n    ) {\n      throw 'WebGL error: Failed to get the storage location of drawing variable';\n    }\n    const drawingVertices = [];\n    if (this.aoi?.length === 0) {\n      drawingVertices.push(-1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0);\n    } else {\n      this.aoi?.forEach((aoi) => {\n        const coordinates = mapboxgl.MercatorCoordinate.fromLngLat(aoi);\n        drawingVertices.push(coordinates.x, coordinates.y);\n      });\n    }\n    this.drawingVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawingVerticesBuffer);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(drawingVertices),\n      gl.STATIC_DRAW,\n    );\n    const computationVertices = this.textureCoverSameAreaAsROI\n      ? drawingVertices\n      : [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];\n    this.computationVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.computationVerticesBuffer);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(computationVertices),\n      gl.STATIC_DRAW,\n    );\n    const indices = earcut(drawingVertices);\n    this.indicesBuffer = gl.createBuffer();\n    if (!this.indicesBuffer)\n      throw new Error('error: indices buffer not created');\n    this.indicesNumber = indices.length;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint8Array(indices),\n      gl.STATIC_DRAW,\n    );\n    this.framebufferWidth = Math.ceil(\n      this.canvas.width * this.framebufferFactor,\n    );\n    this.framebufferHeight = Math.ceil(\n      this.canvas.height * this.framebufferFactor,\n    );\n    this.computationTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA32F,\n      this.framebufferWidth,\n      this.framebufferHeight,\n      0,\n      gl.RGBA,\n      gl.FLOAT,\n      null,\n    );\n    this.computationFramebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.computationFramebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      this.computationTexture,\n      0,\n    );\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    this.points = [];\n    let minValue = Infinity;\n    let maxValue = -Infinity;\n    this.data.forEach((rawPoint) => {\n      const mercatorCoordinates =\n        mapboxgl.MercatorCoordinate.fromLngLat(rawPoint);\n      this.points.push([\n        mercatorCoordinates.x,\n        mercatorCoordinates.y,\n        rawPoint.val,\n      ]);\n      if (rawPoint.val < minValue) {\n        minValue = rawPoint.val;\n      }\n      if (rawPoint.val > maxValue) {\n        maxValue = rawPoint.val;\n      }\n    });\n    minValue = minValue < this.minValue ? minValue : this.minValue;\n    maxValue = maxValue > this.maxValue ? maxValue : this.maxValue;\n    this.points.forEach((point) => {\n      point[2] = (point[2] - minValue) / (maxValue - minValue);\n    });\n    this.resizeFramebuffer = () => {\n      if (!this.canvas || !this.canvas.width || !this.canvas.height)\n        throw new Error('error: required canvas `width` & `height`');\n      this.framebufferWidth = Math.ceil(\n        this.canvas.width * this.framebufferFactor,\n      );\n      this.framebufferHeight = Math.ceil(\n        this.canvas.height * this.framebufferFactor,\n      );\n      gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        this.framebufferWidth,\n        this.framebufferHeight,\n        0,\n        gl.RGBA,\n        gl.FLOAT,\n        null,\n      );\n    };\n    map.on('resize', this.resizeFramebuffer);\n  }\n  onRemove(map: mapboxgl.Map, gl: WebGL2RenderingContext): void {\n    if (!this.resizeFramebuffer)\n      throw new Error('error: required resize frame buffer callback');\n    map.off('resize', this.resizeFramebuffer);\n    gl.deleteTexture(this.computationTexture);\n    gl.deleteBuffer(this.drawingVerticesBuffer);\n    gl.deleteBuffer(this.computationVerticesBuffer);\n    gl.deleteBuffer(this.indicesBuffer);\n    gl.deleteFramebuffer(this.computationFramebuffer);\n  }\n  prerender(gl: WebGL2RenderingContext, matrix: number[]): void {\n    if (\n      !this.framebufferWidth ||\n      !this.framebufferHeight ||\n      this.aPositionComputation === undefined ||\n      !this.indicesNumber ||\n      !this.canvas ||\n      !this.canvas.width ||\n      !this.canvas.height\n    ) {\n      throw new Error('error: missing options for prerendering');\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.enable(gl.BLEND);\n    gl.blendEquation(gl.FUNC_ADD);\n    gl.blendFunc(gl.ONE, gl.ONE);\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    gl.useProgram(this.computationProgram);\n    gl.uniformMatrix4fv(this.uMatrixComputation, false, matrix);\n    gl.uniform1f(this.uP, this.p);\n    gl.uniform2f(\n      this.uFramebufferSize,\n      this.framebufferWidth,\n      this.framebufferHeight,\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.computationFramebuffer);\n    gl.viewport(0, 0, this.framebufferWidth, this.framebufferHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    for (let i = 0; i < this.points.length; i += 1) {\n      const point = this.points.at(i);\n      if (!point) throw new Error(`error: point not found at index: ${i}`);\n      gl.uniform1f(this.uUi, point[2]);\n      gl.uniform2f(this.uXi, point[0], point[1]);\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.computationVerticesBuffer);\n      gl.enableVertexAttribArray(this.aPositionComputation);\n      gl.vertexAttribPointer(\n        this.aPositionComputation,\n        2,\n        gl.FLOAT,\n        false,\n        0,\n        0,\n      );\n      if (this.textureCoverSameAreaAsROI) {\n        gl.drawElements(gl.TRIANGLES, this.indicesNumber, gl.UNSIGNED_BYTE, 0);\n      } else {\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n      }\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  }\n  render(gl: WebGL2RenderingContext, matrix: number[]): void {\n    if (\n      this.aPositionDraw === undefined ||\n      !this.canvas ||\n      !this.canvas.width ||\n      !this.canvas.height ||\n      !this.indicesNumber\n    ) {\n      throw new Error('error: missing options for rendering');\n    }\n    gl.useProgram(this.drawProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawingVerticesBuffer);\n    gl.enableVertexAttribArray(this.aPositionDraw);\n    gl.vertexAttribPointer(this.aPositionDraw, 2, gl.FLOAT, false, 0, 0);\n    gl.uniformMatrix4fv(this.uMatrixDraw, false, matrix);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\n    gl.uniform1i(this.uComputationTexture, 0);\n    gl.uniform2f(this.uScreenSizeDraw, this.canvas.width, this.canvas.height);\n    gl.uniform1f(this.uOpacity, this.opacity);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    gl.drawElements(gl.TRIANGLES, this.indicesNumber, gl.UNSIGNED_BYTE, 0);\n  }\n}\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {string } source - source of the shader\n * @returns {WebGLShader | undefined} - compiled shader\n */\nfunction createVertexShader(\n  gl: WebGL2RenderingContext,\n  source: string,\n): WebGLShader | undefined {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  if (vertexShader) return compileShader(gl, vertexShader, source);\n}\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {string } source - source of the shader\n * @returns {WebGLShader | undefined} - compiled shader\n */\nfunction createFragmentShader(\n  gl: WebGL2RenderingContext,\n  source: string,\n): WebGLShader | undefined {\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  if (fragmentShader) return compileShader(gl, fragmentShader, source);\n}\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {WebGLShader} shader - shader to compile\n * @param {string} source - source of the shader\n * @returns {WebGLShader | undefined} - compiled shader\n */\nfunction compileShader(\n  gl: WebGL2RenderingContext,\n  shader: WebGLShader,\n  source: string,\n): WebGLShader | undefined {\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw gl.getShaderInfoLog(shader);\n  }\n  return shader;\n}\n\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {WebGLShader} vertexShader - vertext shader\n * @param {WebGLShader} fragmentShader - fragment shader\n * @returns {WebGLProgram | null} - compiled program\n */\nfunction createProgram(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram | null {\n  const program = gl.createProgram();\n  if (program) {\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      throw gl.getProgramInfoLog(program);\n    }\n  }\n  return program;\n}\nexport { MapboxInterpolateHeatmapLayer };\n\n"],"names":["MapboxInterpolateHeatmapLayer","options","map","gl","vertexSource","fragmentSource","computationVertexSource","computationFragmentSource","computationVertexShader","createVertexShader","computationFragmentShader","createFragmentShader","createProgram","drawingVertexShader","drawingFragmentShader","drawingVertices","aoi","coordinates","mapboxgl","computationVertices","indices","earcut","minValue","maxValue","rawPoint","mercatorCoordinates","point","matrix","source","vertexShader","compileShader","fragmentShader","shader","program"],"mappings":"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"}