{"version":3,"file":"mapbox-gl-interpolate-heatmap.js","sources":["../src/layer.ts"],"sourcesContent":["import earcut from 'earcut';\nimport mapboxgl, { CustomLayerInterface } from 'mapbox-gl';\n\ntype MapboxInterpolateHeatmapLayerOptions = {\n  id: string;\n  data: { lat: number; lon: number; val: number }[];\n  framebufferFactor?: number;\n  maxValue?: number;\n  minValue?: number;\n  opacity?: number;\n  p?: number;\n  aoi?: { lat: number; lon: number }[];\n  valueToColor?: string;\n  valueToColor4?: string;\n  textureCoverSameAreaAsROI?: boolean;\n};\n\nclass MapboxInterpolateHeatmapLayer implements CustomLayerInterface {\n  id: string;\n  data: { lat: number; lon: number; val: number }[];\n  framebufferFactor: number;\n  maxValue: number;\n  minValue: number;\n  opacity: number;\n  p: number;\n  aoi?: { lat: number; lon: number }[];\n  valueToColor?: string;\n  valueToColor4?: string;\n  textureCoverSameAreaAsROI: boolean;\n  points: number[][] = [];\n  // Custom Props\n  aPositionComputation?: number;\n  aPositionDraw?: number;\n  canvas?: HTMLCanvasElement;\n  computationFramebuffer: WebGLFramebuffer | null = null;\n  computationProgram: WebGLProgram | null = null;\n  computationTexture: WebGLTexture | null = null;\n  computationVerticesBuffer: WebGLBuffer | null = null;\n  drawingVerticesBuffer: WebGLBuffer | null = null;\n  drawProgram: WebGLProgram | null = null;\n  framebufferHeight?: number;\n  framebufferWidth?: number;\n  indicesBuffer: WebGLBuffer | null = null;\n  indicesNumber: number | null = null;\n  renderingMode: '2d' | '3d' = '2d';\n  resizeFramebuffer?: () => void;\n  type: 'custom' = 'custom' as const;\n  uComputationTexture: WebGLUniformLocation | null = null;\n  uFramebufferSize: WebGLUniformLocation | null = null;\n  uMatrixComputation: WebGLUniformLocation | null = null;\n  uMatrixDraw: WebGLUniformLocation | null = null;\n  uOpacity: WebGLUniformLocation | null = null;\n  uP: WebGLUniformLocation | null = null;\n  uScreenSizeDraw: WebGLUniformLocation | null = null;\n  uUi: WebGLUniformLocation | null = null;\n  uXi: WebGLUniformLocation | null = null;\n\n  constructor(options: MapboxInterpolateHeatmapLayerOptions) {\n    this.id = options.id || '';\n    this.data = options.data || [];\n    this.aoi = options.aoi || [];\n    this.valueToColor =\n      options.valueToColor ||\n      `\n      vec3 valueToColor(float value) {\n          return vec3(max((value-0.5)*2.0, 0.0), 1.0 - 2.0*abs(value - 0.5), max((0.5-value)*2.0, 0.0));\n      }\n  `;\n    this.valueToColor4 =\n      options.valueToColor4 ||\n      `\n      vec4 valueToColor4(float value, float defaultOpacity) {\n          return vec4(valueToColor(value), defaultOpacity);\n      }\n  `;\n    this.opacity = options.opacity ?? 0.5;\n    this.minValue = options.minValue ?? Infinity;\n    this.maxValue = options.maxValue ?? -Infinity;\n    this.p = options.p ?? 3;\n    this.framebufferFactor = options.framebufferFactor ?? 0.3;\n    // Having a framebufferFactor < 1 and a texture that don't cover the entire map results in visual artifacts, so we prevent this situation\n    this.textureCoverSameAreaAsROI = this.framebufferFactor === 1;\n  }\n\n  onAdd(map: mapboxgl.Map, gl: WebGL2RenderingContext): void {\n    if (\n      !gl.getExtension('EXT_color_buffer_float') ||\n      !gl.getExtension('EXT_float_blend')\n    ) {\n      throw 'WebGL extension not supported';\n    }\n    this.canvas = map.getCanvas();\n    const vertexSource = `\n              precision highp float;\n              attribute vec2 a_Position;\n              uniform mat4 u_Matrix;\n              void main() {\n                  gl_Position = u_Matrix * vec4(a_Position, 0.0, 1.0);\n              }\n          `;\n    const fragmentSource = `\n              precision highp float;\n              ${this.valueToColor}\n              ${this.valueToColor4}\n              uniform sampler2D u_ComputationTexture;\n              uniform vec2 u_ScreenSize;\n              uniform float u_Opacity;\n              void main(void) {\n                  vec4 data = texture2D(u_ComputationTexture, vec2(gl_FragCoord.x/u_ScreenSize.x, gl_FragCoord.y/u_ScreenSize.y));\n                  float u = data.x/data.y;\n                  u += u_Opacity*0.00000001; // force WebGL to use u_Opacity. This might not be the case depending on valueToColor4\n                  gl_FragColor = valueToColor4(u, u_Opacity);\n              }\n          `;\n    const computationVertexSource = `\n              precision highp float;\n              uniform mat4 u_Matrix;\n              uniform vec2 xi;\n              varying vec2 xiNormalized;\n              attribute vec2 a_Position;\n              void main() {\n                  vec4 xiProjected = u_Matrix * vec4(xi, 0.0, 1.0);\n                  xiNormalized = vec2(xiProjected.x / xiProjected.w, xiProjected.y / xiProjected.w);\n                  gl_Position = u_Matrix * vec4(a_Position, 0.0, 1.0);\n              }\n          `;\n    const computationFragmentSource = `\n              precision highp float;\n              uniform float ui;\n              varying vec2 xiNormalized;\n              uniform float p;\n              uniform vec2 u_FramebufferSize;\n              void main() {\n                  vec2 x = vec2(gl_FragCoord.x/u_FramebufferSize.x, gl_FragCoord.y/u_FramebufferSize.y);\n                  vec2 xi = vec2((xiNormalized.x + 1.)/2., (xiNormalized.y + 1.)/2.);\n                  float dist = distance(x, xi);\n                  float wi = 1.0/pow(dist, p);\n                  gl_FragColor = vec4(ui*wi, wi, 0.0, 1.0);\n              }\n          `;\n    const computationVertexShader = createVertexShader(\n      gl,\n      computationVertexSource,\n    );\n    if (!computationVertexShader)\n      throw new Error('error: computation vertex shader not created');\n    const computationFragmentShader = createFragmentShader(\n      gl,\n      computationFragmentSource,\n    );\n    if (!computationFragmentShader)\n      throw new Error('error: computation fragment shader not created');\n    this.computationProgram = createProgram(\n      gl,\n      computationVertexShader,\n      computationFragmentShader,\n    );\n    if (!this.computationProgram)\n      throw new Error('error: computation fragment shader not created');\n    this.aPositionComputation = gl.getAttribLocation(\n      this.computationProgram,\n      'a_Position',\n    );\n    this.uMatrixComputation = gl.getUniformLocation(\n      this.computationProgram,\n      'u_Matrix',\n    );\n    this.uUi = gl.getUniformLocation(this.computationProgram, 'ui');\n    this.uXi = gl.getUniformLocation(this.computationProgram, 'xi');\n    this.uP = gl.getUniformLocation(this.computationProgram, 'p');\n    this.uFramebufferSize = gl.getUniformLocation(\n      this.computationProgram,\n      'u_FramebufferSize',\n    );\n    if (\n      this.aPositionComputation < 0 ||\n      !this.uMatrixComputation ||\n      !this.uUi ||\n      !this.uXi ||\n      !this.uP ||\n      !this.uFramebufferSize\n    ) {\n      throw 'WebGL error: Failed to get the storage location of computation variable';\n    }\n    const drawingVertexShader = createVertexShader(gl, vertexSource);\n    if (!drawingVertexShader)\n      throw new Error('error: drawing vertex shader not created');\n    const drawingFragmentShader = createFragmentShader(gl, fragmentSource);\n    if (!drawingFragmentShader)\n      throw new Error('error: drawing fragment shader not created');\n    this.drawProgram = createProgram(\n      gl,\n      drawingVertexShader,\n      drawingFragmentShader,\n    );\n    if (!this.drawProgram)\n      throw new Error('error: drawing program not created');\n    this.aPositionDraw = gl.getAttribLocation(this.drawProgram, 'a_Position');\n    this.uMatrixDraw = gl.getUniformLocation(this.drawProgram, 'u_Matrix');\n    this.uComputationTexture = gl.getUniformLocation(\n      this.drawProgram,\n      'u_ComputationTexture',\n    );\n    this.uScreenSizeDraw = gl.getUniformLocation(\n      this.drawProgram,\n      'u_ScreenSize',\n    );\n    this.uOpacity = gl.getUniformLocation(this.drawProgram, 'u_Opacity');\n    if (\n      this.aPositionDraw < 0 ||\n      !this.uMatrixDraw ||\n      !this.uComputationTexture ||\n      !this.uScreenSizeDraw ||\n      !this.uOpacity\n    ) {\n      throw 'WebGL error: Failed to get the storage location of drawing variable';\n    }\n    const drawingVertices = [];\n    if (this.aoi?.length === 0) {\n      drawingVertices.push(-1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0);\n    } else {\n      this.aoi?.forEach((aoi) => {\n        const coordinates = mapboxgl.MercatorCoordinate.fromLngLat(aoi);\n        drawingVertices.push(coordinates.x, coordinates.y);\n      });\n    }\n    this.drawingVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawingVerticesBuffer);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(drawingVertices),\n      gl.STATIC_DRAW,\n    );\n    const computationVertices = this.textureCoverSameAreaAsROI\n      ? drawingVertices\n      : [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];\n    this.computationVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.computationVerticesBuffer);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(computationVertices),\n      gl.STATIC_DRAW,\n    );\n    const indices = earcut(drawingVertices);\n    this.indicesBuffer = gl.createBuffer();\n    if (!this.indicesBuffer)\n      throw new Error('error: indices buffer not created');\n    this.indicesNumber = indices.length;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Uint8Array(indices),\n      gl.STATIC_DRAW,\n    );\n    this.framebufferWidth = Math.ceil(\n      this.canvas.width * this.framebufferFactor,\n    );\n    this.framebufferHeight = Math.ceil(\n      this.canvas.height * this.framebufferFactor,\n    );\n    this.computationTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA32F,\n      this.framebufferWidth,\n      this.framebufferHeight,\n      0,\n      gl.RGBA,\n      gl.FLOAT,\n      null,\n    );\n    this.computationFramebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.computationFramebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      this.computationTexture,\n      0,\n    );\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    this.points = [];\n    let minValue = Infinity;\n    let maxValue = -Infinity;\n    this.data.forEach((rawPoint) => {\n      const mercatorCoordinates =\n        mapboxgl.MercatorCoordinate.fromLngLat(rawPoint);\n      this.points.push([\n        mercatorCoordinates.x,\n        mercatorCoordinates.y,\n        rawPoint.val,\n      ]);\n      if (rawPoint.val < minValue) {\n        minValue = rawPoint.val;\n      }\n      if (rawPoint.val > maxValue) {\n        maxValue = rawPoint.val;\n      }\n    });\n    minValue = minValue < this.minValue ? minValue : this.minValue;\n    maxValue = maxValue > this.maxValue ? maxValue : this.maxValue;\n    this.points.forEach((point) => {\n      point[2] = (point[2] - minValue) / (maxValue - minValue);\n    });\n    this.resizeFramebuffer = () => {\n      if (!this.canvas || !this.canvas.width || !this.canvas.height)\n        throw new Error('error: required canvas `width` & `height`');\n      this.framebufferWidth = Math.ceil(\n        this.canvas.width * this.framebufferFactor,\n      );\n      this.framebufferHeight = Math.ceil(\n        this.canvas.height * this.framebufferFactor,\n      );\n      gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        this.framebufferWidth,\n        this.framebufferHeight,\n        0,\n        gl.RGBA,\n        gl.FLOAT,\n        null,\n      );\n    };\n    map.on('resize', this.resizeFramebuffer);\n  }\n  onRemove(map: mapboxgl.Map, gl: WebGL2RenderingContext): void {\n    if (!this.resizeFramebuffer)\n      throw new Error('error: required resize frame buffer callback');\n    map.off('resize', this.resizeFramebuffer);\n    gl.deleteTexture(this.computationTexture);\n    gl.deleteBuffer(this.drawingVerticesBuffer);\n    gl.deleteBuffer(this.computationVerticesBuffer);\n    gl.deleteBuffer(this.indicesBuffer);\n    gl.deleteFramebuffer(this.computationFramebuffer);\n  }\n  prerender(gl: WebGL2RenderingContext, matrix: number[]): void {\n    if (\n      !this.framebufferWidth ||\n      !this.framebufferHeight ||\n      this.aPositionComputation === undefined ||\n      !this.indicesNumber ||\n      !this.canvas ||\n      !this.canvas.width ||\n      !this.canvas.height\n    ) {\n      throw new Error('error: missing options for prerendering');\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.enable(gl.BLEND);\n    gl.blendEquation(gl.FUNC_ADD);\n    gl.blendFunc(gl.ONE, gl.ONE);\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    gl.useProgram(this.computationProgram);\n    gl.uniformMatrix4fv(this.uMatrixComputation, false, matrix);\n    gl.uniform1f(this.uP, this.p);\n    gl.uniform2f(\n      this.uFramebufferSize,\n      this.framebufferWidth,\n      this.framebufferHeight,\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.computationFramebuffer);\n    gl.viewport(0, 0, this.framebufferWidth, this.framebufferHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    for (let i = 0; i < this.points.length; i += 1) {\n      const point = this.points.at(i);\n      if (!point) throw new Error(`error: point not found at index: ${i}`);\n      gl.uniform1f(this.uUi, point[2]);\n      gl.uniform2f(this.uXi, point[0], point[1]);\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.computationVerticesBuffer);\n      gl.enableVertexAttribArray(this.aPositionComputation);\n      gl.vertexAttribPointer(\n        this.aPositionComputation,\n        2,\n        gl.FLOAT,\n        false,\n        0,\n        0,\n      );\n      if (this.textureCoverSameAreaAsROI) {\n        gl.drawElements(gl.TRIANGLES, this.indicesNumber, gl.UNSIGNED_BYTE, 0);\n      } else {\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n      }\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n  }\n  render(gl: WebGL2RenderingContext, matrix: number[]): void {\n    if (\n      this.aPositionDraw === undefined ||\n      !this.canvas ||\n      !this.canvas.width ||\n      !this.canvas.height ||\n      !this.indicesNumber\n    ) {\n      throw new Error('error: missing options for rendering');\n    }\n    gl.useProgram(this.drawProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawingVerticesBuffer);\n    gl.enableVertexAttribArray(this.aPositionDraw);\n    gl.vertexAttribPointer(this.aPositionDraw, 2, gl.FLOAT, false, 0, 0);\n    gl.uniformMatrix4fv(this.uMatrixDraw, false, matrix);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\n    gl.uniform1i(this.uComputationTexture, 0);\n    gl.uniform2f(this.uScreenSizeDraw, this.canvas.width, this.canvas.height);\n    gl.uniform1f(this.uOpacity, this.opacity);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n    gl.drawElements(gl.TRIANGLES, this.indicesNumber, gl.UNSIGNED_BYTE, 0);\n  }\n}\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {string } source - source of the shader\n * @returns {WebGLShader | undefined} - compiled shader\n */\nfunction createVertexShader(\n  gl: WebGL2RenderingContext,\n  source: string,\n): WebGLShader | undefined {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  if (vertexShader) return compileShader(gl, vertexShader, source);\n}\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {string } source - source of the shader\n * @returns {WebGLShader | undefined} - compiled shader\n */\nfunction createFragmentShader(\n  gl: WebGL2RenderingContext,\n  source: string,\n): WebGLShader | undefined {\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  if (fragmentShader) return compileShader(gl, fragmentShader, source);\n}\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {WebGLShader} shader - shader to compile\n * @param {string} source - source of the shader\n * @returns {WebGLShader | undefined} - compiled shader\n */\nfunction compileShader(\n  gl: WebGL2RenderingContext,\n  shader: WebGLShader,\n  source: string,\n): WebGLShader | undefined {\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw gl.getShaderInfoLog(shader);\n  }\n  return shader;\n}\n\n/**\n * @param {WebGL2RenderingContext} gl - WebGL context\n * @param {WebGLShader} vertexShader - vertext shader\n * @param {WebGLShader} fragmentShader - fragment shader\n * @returns {WebGLProgram | null} - compiled program\n */\nfunction createProgram(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n): WebGLProgram | null {\n  const program = gl.createProgram();\n  if (program) {\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      throw gl.getProgramInfoLog(program);\n    }\n  }\n  return program;\n}\nexport { MapboxInterpolateHeatmapLayer };\n\n"],"names":["MapboxInterpolateHeatmapLayer","options","map","gl","vertexSource","fragmentSource","computationVertexSource","computationFragmentSource","computationVertexShader","createVertexShader","computationFragmentShader","createFragmentShader","createProgram","drawingVertexShader","drawingFragmentShader","drawingVertices","aoi","coordinates","mapboxgl","computationVertices","indices","earcut","minValue","maxValue","rawPoint","mercatorCoordinates","point","matrix","source","vertexShader","compileShader","fragmentShader","shader","program"],"mappings":"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"}