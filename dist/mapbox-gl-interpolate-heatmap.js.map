{"version":3,"file":"mapbox-gl-interpolate-heatmap.js","sources":["../src/layer.ts"],"sourcesContent":["import earcut from 'earcut';\r\nimport mapboxgl, { CustomLayerInterface } from 'mapbox-gl';\r\n\r\ntype MapboxInterpolateHeatmapLayerOptions = {\r\n  id: string;\r\n  data: { lat: number; lon: number; val: number }[];\r\n  framebufferFactor?: number;\r\n  maxValue?: number;\r\n  minValue?: number;\r\n  opacity?: number;\r\n  p?: number;\r\n  aoi?: { lat: number; lon: number }[];\r\n  valueToColor?: string;\r\n  valueToColor4?: string;\r\n  textureCoverSameAreaAsROI?: boolean;\r\n};\r\n\r\nclass MapboxInterpolateHeatmapLayer implements CustomLayerInterface {\r\n  id: string;\r\n  data: { lat: number; lon: number; val: number }[];\r\n  framebufferFactor: number;\r\n  maxValue: number;\r\n  minValue: number;\r\n  opacity: number;\r\n  p: number;\r\n  aoi?: { lat: number; lon: number }[];\r\n  valueToColor?: string;\r\n  valueToColor4?: string;\r\n  textureCoverSameAreaAsROI: boolean;\r\n  points: number[][] = [];\r\n  // Custom Props\r\n  aPositionComputation?: number;\r\n  aPositionDraw?: number;\r\n  canvas?: HTMLCanvasElement;\r\n  computationFramebuffer: WebGLFramebuffer | null = null;\r\n  computationProgram: WebGLProgram | null = null;\r\n  computationTexture: WebGLTexture | null = null;\r\n  computationVerticesBuffer: WebGLBuffer | null = null;\r\n  drawingVerticesBuffer: WebGLBuffer | null = null;\r\n  drawProgram: WebGLProgram | null = null;\r\n  framebufferHeight?: number;\r\n  framebufferWidth?: number;\r\n  indicesBuffer: WebGLBuffer | null = null;\r\n  indicesNumber: number | null = null;\r\n  renderingMode: '2d' | '3d' = '2d';\r\n  resizeFramebuffer?: () => void;\r\n  type: 'custom' = 'custom' as const;\r\n  uComputationTexture: WebGLUniformLocation | null = null;\r\n  uFramebufferSize: WebGLUniformLocation | null = null;\r\n  uMatrixComputation: WebGLUniformLocation | null = null;\r\n  uMatrixDraw: WebGLUniformLocation | null = null;\r\n  uOpacity: WebGLUniformLocation | null = null;\r\n  uP: WebGLUniformLocation | null = null;\r\n  uScreenSizeDraw: WebGLUniformLocation | null = null;\r\n  uUi: WebGLUniformLocation | null = null;\r\n  uXi: WebGLUniformLocation | null = null;\r\n\r\n  constructor(options: MapboxInterpolateHeatmapLayerOptions) {\r\n    this.id = options.id || '';\r\n    this.data = options.data || [];\r\n    this.aoi = options.aoi || [];\r\n    this.valueToColor =\r\n      options.valueToColor ||\r\n      `\r\n      vec3 valueToColor(float value) {\r\n          return vec3(max((value-0.5)*2.0, 0.0), 1.0 - 2.0*abs(value - 0.5), max((0.5-value)*2.0, 0.0));\r\n      }\r\n  `;\r\n    this.valueToColor4 =\r\n      options.valueToColor4 ||\r\n      `\r\n      vec4 valueToColor4(float value, float defaultOpacity) {\r\n          return vec4(valueToColor(value), defaultOpacity);\r\n      }\r\n  `;\r\n    this.opacity = options.opacity ?? 0.5;\r\n    this.minValue = options.minValue ?? Infinity;\r\n    this.maxValue = options.maxValue ?? -Infinity;\r\n    this.p = options.p ?? 3;\r\n    this.framebufferFactor = options.framebufferFactor ?? 0.3;\r\n    // Having a framebufferFactor < 1 and a texture that don't cover the entire map results in visual artifacts, so we prevent this situation\r\n    this.textureCoverSameAreaAsROI = this.framebufferFactor === 1;\r\n  }\r\n\r\n  onAdd(map: mapboxgl.Map, gl: WebGLRenderingContext): void {\r\n    if (\r\n      !gl.getExtension('OES_texture_float') ||\r\n      !gl.getExtension('WEBGL_color_buffer_float') ||\r\n      !gl.getExtension('EXT_float_blend')\r\n    ) {\r\n      throw 'WebGL extension not supported';\r\n    }\r\n    this.canvas = map.getCanvas();\r\n    const vertexSource = `\r\n              precision highp float;\r\n              attribute vec2 a_Position;\r\n              uniform mat4 u_Matrix;\r\n              void main() {\r\n                  gl_Position = u_Matrix * vec4(a_Position, 0.0, 1.0);\r\n              }\r\n          `;\r\n    const fragmentSource = `\r\n              precision highp float;\r\n              ${this.valueToColor}\r\n              ${this.valueToColor4}\r\n              uniform sampler2D u_ComputationTexture;\r\n              uniform vec2 u_ScreenSize;\r\n              uniform float u_Opacity;\r\n              void main(void) {\r\n                  vec4 data = texture2D(u_ComputationTexture, vec2(gl_FragCoord.x/u_ScreenSize.x, gl_FragCoord.y/u_ScreenSize.y));\r\n                  float u = data.x/data.y;\r\n                  u += u_Opacity*0.00000001; // force WebGL to use u_Opacity. This might not be the case depending on valueToColor4\r\n                  gl_FragColor = valueToColor4(u, u_Opacity);\r\n              }\r\n          `;\r\n    const computationVertexSource = `\r\n              precision highp float;\r\n              uniform mat4 u_Matrix;\r\n              uniform vec2 xi;\r\n              varying vec2 xiNormalized;\r\n              attribute vec2 a_Position;\r\n              void main() {\r\n                  vec4 xiProjected = u_Matrix * vec4(xi, 0.0, 1.0);\r\n                  xiNormalized = vec2(xiProjected.x / xiProjected.w, xiProjected.y / xiProjected.w);\r\n                  gl_Position = u_Matrix * vec4(a_Position, 0.0, 1.0);\r\n              }\r\n          `;\r\n    const computationFragmentSource = `\r\n              precision highp float;\r\n              uniform float ui;\r\n              varying vec2 xiNormalized;\r\n              uniform float p;\r\n              uniform vec2 u_FramebufferSize;\r\n              void main() {\r\n                  vec2 x = vec2(gl_FragCoord.x/u_FramebufferSize.x, gl_FragCoord.y/u_FramebufferSize.y);\r\n                  vec2 xi = vec2((xiNormalized.x + 1.)/2., (xiNormalized.y + 1.)/2.);\r\n                  float dist = distance(x, xi);\r\n                  float wi = 1.0/pow(dist, p);\r\n                  gl_FragColor = vec4(ui*wi, wi, 0.0, 1.0);\r\n              }\r\n          `;\r\n    const computationVertexShader = createVertexShader(\r\n      gl,\r\n      computationVertexSource,\r\n    );\r\n    if (!computationVertexShader)\r\n      throw new Error('error: computation vertex shader not created');\r\n    const computationFragmentShader = createFragmentShader(\r\n      gl,\r\n      computationFragmentSource,\r\n    );\r\n    if (!computationFragmentShader)\r\n      throw new Error('error: computation fragment shader not created');\r\n    this.computationProgram = createProgram(\r\n      gl,\r\n      computationVertexShader,\r\n      computationFragmentShader,\r\n    );\r\n    if (!this.computationProgram)\r\n      throw new Error('error: computation fragment shader not created');\r\n    this.aPositionComputation = gl.getAttribLocation(\r\n      this.computationProgram,\r\n      'a_Position',\r\n    );\r\n    this.uMatrixComputation = gl.getUniformLocation(\r\n      this.computationProgram,\r\n      'u_Matrix',\r\n    );\r\n    this.uUi = gl.getUniformLocation(this.computationProgram, 'ui');\r\n    this.uXi = gl.getUniformLocation(this.computationProgram, 'xi');\r\n    this.uP = gl.getUniformLocation(this.computationProgram, 'p');\r\n    this.uFramebufferSize = gl.getUniformLocation(\r\n      this.computationProgram,\r\n      'u_FramebufferSize',\r\n    );\r\n    if (\r\n      this.aPositionComputation < 0 ||\r\n      !this.uMatrixComputation ||\r\n      !this.uUi ||\r\n      !this.uXi ||\r\n      !this.uP ||\r\n      !this.uFramebufferSize\r\n    ) {\r\n      throw 'WebGL error: Failed to get the storage location of computation variable';\r\n    }\r\n    const drawingVertexShader = createVertexShader(gl, vertexSource);\r\n    if (!drawingVertexShader)\r\n      throw new Error('error: drawing vertex shader not created');\r\n    const drawingFragmentShader = createFragmentShader(gl, fragmentSource);\r\n    if (!drawingFragmentShader)\r\n      throw new Error('error: drawing fragment shader not created');\r\n    this.drawProgram = createProgram(\r\n      gl,\r\n      drawingVertexShader,\r\n      drawingFragmentShader,\r\n    );\r\n    if (!this.drawProgram)\r\n      throw new Error('error: drawing program not created');\r\n    this.aPositionDraw = gl.getAttribLocation(this.drawProgram, 'a_Position');\r\n    this.uMatrixDraw = gl.getUniformLocation(this.drawProgram, 'u_Matrix');\r\n    this.uComputationTexture = gl.getUniformLocation(\r\n      this.drawProgram,\r\n      'u_ComputationTexture',\r\n    );\r\n    this.uScreenSizeDraw = gl.getUniformLocation(\r\n      this.drawProgram,\r\n      'u_ScreenSize',\r\n    );\r\n    this.uOpacity = gl.getUniformLocation(this.drawProgram, 'u_Opacity');\r\n    if (\r\n      this.aPositionDraw < 0 ||\r\n      !this.uMatrixDraw ||\r\n      !this.uComputationTexture ||\r\n      !this.uScreenSizeDraw ||\r\n      !this.uOpacity\r\n    ) {\r\n      throw 'WebGL error: Failed to get the storage location of drawing variable';\r\n    }\r\n    const drawingVertices = [];\r\n    if (this.aoi?.length === 0) {\r\n      drawingVertices.push(-1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0);\r\n    } else {\r\n      this.aoi?.forEach((aoi) => {\r\n        const coordinates = mapboxgl.MercatorCoordinate.fromLngLat(aoi);\r\n        drawingVertices.push(coordinates.x, coordinates.y);\r\n      });\r\n    }\r\n    this.drawingVerticesBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawingVerticesBuffer);\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array(drawingVertices),\r\n      gl.STATIC_DRAW,\r\n    );\r\n    const computationVertices = this.textureCoverSameAreaAsROI\r\n      ? drawingVertices\r\n      : [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];\r\n    this.computationVerticesBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.computationVerticesBuffer);\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array(computationVertices),\r\n      gl.STATIC_DRAW,\r\n    );\r\n    const indices = earcut(drawingVertices);\r\n    this.indicesBuffer = gl.createBuffer();\r\n    if (!this.indicesBuffer)\r\n      throw new Error('error: indices buffer not created');\r\n    this.indicesNumber = indices.length;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n    gl.bufferData(\r\n      gl.ELEMENT_ARRAY_BUFFER,\r\n      new Uint8Array(indices),\r\n      gl.STATIC_DRAW,\r\n    );\r\n    this.framebufferWidth = Math.ceil(\r\n      this.canvas.width * this.framebufferFactor,\r\n    );\r\n    this.framebufferHeight = Math.ceil(\r\n      this.canvas.height * this.framebufferFactor,\r\n    );\r\n    this.computationTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,\r\n      0,\r\n      gl.RGBA,\r\n      this.framebufferWidth,\r\n      this.framebufferHeight,\r\n      0,\r\n      gl.RGBA,\r\n      gl.FLOAT,\r\n      null,\r\n    );\r\n    this.computationFramebuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.computationFramebuffer);\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER,\r\n      gl.COLOR_ATTACHMENT0,\r\n      gl.TEXTURE_2D,\r\n      this.computationTexture,\r\n      0,\r\n    );\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    this.points = [];\r\n    let minValue = Infinity;\r\n    let maxValue = -Infinity;\r\n    this.data.forEach((rawPoint) => {\r\n      const mercatorCoordinates =\r\n        mapboxgl.MercatorCoordinate.fromLngLat(rawPoint);\r\n      this.points.push([\r\n        mercatorCoordinates.x,\r\n        mercatorCoordinates.y,\r\n        rawPoint.val,\r\n      ]);\r\n      if (rawPoint.val < minValue) {\r\n        minValue = rawPoint.val;\r\n      }\r\n      if (rawPoint.val > maxValue) {\r\n        maxValue = rawPoint.val;\r\n      }\r\n    });\r\n    minValue = minValue < this.minValue ? minValue : this.minValue;\r\n    maxValue = maxValue > this.maxValue ? maxValue : this.maxValue;\r\n    this.points.forEach((point) => {\r\n      point[2] = (point[2] - minValue) / (maxValue - minValue);\r\n    });\r\n    this.resizeFramebuffer = () => {\r\n      if (!this.canvas || !this.canvas.width || !this.canvas.height)\r\n        throw new Error('error: required canvas `width` & `height`');\r\n      this.framebufferWidth = Math.ceil(\r\n        this.canvas.width * this.framebufferFactor,\r\n      );\r\n      this.framebufferHeight = Math.ceil(\r\n        this.canvas.height * this.framebufferFactor,\r\n      );\r\n      gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        this.framebufferWidth,\r\n        this.framebufferHeight,\r\n        0,\r\n        gl.RGBA,\r\n        gl.FLOAT,\r\n        null,\r\n      );\r\n    };\r\n    map.on('resize', this.resizeFramebuffer);\r\n  }\r\n  onRemove(map: mapboxgl.Map, gl: WebGLRenderingContext): void {\r\n    if (!this.resizeFramebuffer)\r\n      throw new Error('error: required resize frame buffer callback');\r\n    map.off('resize', this.resizeFramebuffer);\r\n    gl.deleteTexture(this.computationTexture);\r\n    gl.deleteBuffer(this.drawingVerticesBuffer);\r\n    gl.deleteBuffer(this.computationVerticesBuffer);\r\n    gl.deleteBuffer(this.indicesBuffer);\r\n    gl.deleteFramebuffer(this.computationFramebuffer);\r\n  }\r\n  prerender(gl: WebGLRenderingContext, matrix: number[]): void {\r\n    if (\r\n      !this.framebufferWidth ||\r\n      !this.framebufferHeight ||\r\n      this.aPositionComputation === undefined ||\r\n      !this.indicesNumber ||\r\n      !this.canvas ||\r\n      !this.canvas.width ||\r\n      !this.canvas.height\r\n    ) {\r\n      throw new Error('error: missing options for prerendering');\r\n    }\r\n    gl.disable(gl.DEPTH_TEST);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendEquation(gl.FUNC_ADD);\r\n    gl.blendFunc(gl.ONE, gl.ONE);\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    gl.useProgram(this.computationProgram);\r\n    gl.uniformMatrix4fv(this.uMatrixComputation, false, matrix);\r\n    gl.uniform1f(this.uP, this.p);\r\n    gl.uniform2f(\r\n      this.uFramebufferSize,\r\n      this.framebufferWidth,\r\n      this.framebufferHeight,\r\n    );\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.computationFramebuffer);\r\n    gl.viewport(0, 0, this.framebufferWidth, this.framebufferHeight);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n    for (let i = 0; i < this.points.length; i += 1) {\r\n      const point = this.points.at(i);\r\n      if (!point) throw new Error(`error: point not found at index: ${i}`);\r\n      gl.uniform1f(this.uUi, point[2]);\r\n      gl.uniform2f(this.uXi, point[0], point[1]);\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.computationVerticesBuffer);\r\n      gl.enableVertexAttribArray(this.aPositionComputation);\r\n      gl.vertexAttribPointer(\r\n        this.aPositionComputation,\r\n        2,\r\n        gl.FLOAT,\r\n        false,\r\n        0,\r\n        0,\r\n      );\r\n      if (this.textureCoverSameAreaAsROI) {\r\n        gl.drawElements(gl.TRIANGLES, this.indicesNumber, gl.UNSIGNED_BYTE, 0);\r\n      } else {\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n      }\r\n    }\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    gl.viewport(0, 0, this.canvas.width, this.canvas.height);\r\n  }\r\n  render(gl: WebGLRenderingContext, matrix: number[]): void {\r\n    if (\r\n      this.aPositionDraw === undefined ||\r\n      !this.canvas ||\r\n      !this.canvas.width ||\r\n      !this.canvas.height ||\r\n      !this.indicesNumber\r\n    ) {\r\n      throw new Error('error: missing options for rendering');\r\n    }\r\n    gl.useProgram(this.drawProgram);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawingVerticesBuffer);\r\n    gl.enableVertexAttribArray(this.aPositionDraw);\r\n    gl.vertexAttribPointer(this.aPositionDraw, 2, gl.FLOAT, false, 0, 0);\r\n    gl.uniformMatrix4fv(this.uMatrixDraw, false, matrix);\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this.computationTexture);\r\n    gl.uniform1i(this.uComputationTexture, 0);\r\n    gl.uniform2f(this.uScreenSizeDraw, this.canvas.width, this.canvas.height);\r\n    gl.uniform1f(this.uOpacity, this.opacity);\r\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n    gl.drawElements(gl.TRIANGLES, this.indicesNumber, gl.UNSIGNED_BYTE, 0);\r\n  }\r\n}\r\n/**\r\n * @param {WebGLRenderingContext} gl - WebGL context\r\n * @param {string } source - source of the shader\r\n * @returns {WebGLShader | undefined} - compiled shader\r\n */\r\nfunction createVertexShader(\r\n  gl: WebGLRenderingContext,\r\n  source: string,\r\n): WebGLShader | undefined {\r\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n  if (vertexShader) return compileShader(gl, vertexShader, source);\r\n}\r\n/**\r\n * @param {WebGLRenderingContext} gl - WebGL context\r\n * @param {string } source - source of the shader\r\n * @returns {WebGLShader | undefined} - compiled shader\r\n */\r\nfunction createFragmentShader(\r\n  gl: WebGLRenderingContext,\r\n  source: string,\r\n): WebGLShader | undefined {\r\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n  if (fragmentShader) return compileShader(gl, fragmentShader, source);\r\n}\r\n/**\r\n * @param {WebGLRenderingContext} gl - WebGL context\r\n * @param {WebGLShader} shader - shader to compile\r\n * @param {string} source - source of the shader\r\n * @returns {WebGLShader | undefined} - compiled shader\r\n */\r\nfunction compileShader(\r\n  gl: WebGLRenderingContext,\r\n  shader: WebGLShader,\r\n  source: string,\r\n): WebGLShader | undefined {\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    throw gl.getShaderInfoLog(shader);\r\n  }\r\n  return shader;\r\n}\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl - WebGL context\r\n * @param {WebGLShader} vertexShader - vertext shader\r\n * @param {WebGLShader} fragmentShader - fragment shader\r\n * @returns {WebGLProgram | null} - compiled program\r\n */\r\nfunction createProgram(\r\n  gl: WebGLRenderingContext,\r\n  vertexShader: WebGLShader,\r\n  fragmentShader: WebGLShader,\r\n): WebGLProgram | null {\r\n  const program = gl.createProgram();\r\n  if (program) {\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      throw gl.getProgramInfoLog(program);\r\n    }\r\n  }\r\n  return program;\r\n}\r\nexport { MapboxInterpolateHeatmapLayer };\r\n\r\n"],"names":["MapboxInterpolateHeatmapLayer","options","map","gl","vertexSource","fragmentSource","computationVertexSource","computationFragmentSource","computationVertexShader","createVertexShader","computationFragmentShader","createFragmentShader","createProgram","drawingVertexShader","drawingFragmentShader","drawingVertices","aoi","coordinates","mapboxgl","computationVertices","indices","earcut","minValue","maxValue","rawPoint","mercatorCoordinates","point","matrix","source","vertexShader","compileShader","fragmentShader","shader","program"],"mappings":"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"}